{
  "version": 3,
  "sources": ["../../ol/interaction/Snap.js", "dep:ol_interaction_Snap"],
  "sourcesContent": ["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_,\n    ]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    const segments = this.rBush_.getInExtent(box);\n\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(\n            closestOnCircle(\n              projectedCoordinate,\n              /** @type {import(\"../geom/Circle.js\").default} */ (\n                circleGeometry\n              )\n            ),\n            projection\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n", "import d from \"./node_modules/ol/interaction/Snap.js\";export default d;"],
  "mappings": "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",
  "names": []
}
